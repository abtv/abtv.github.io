{"pageProps":{"title":"Async architecture","content":"### 1.1. What microservice architecture is\nKey points:\n- a microservice should be rewritten in 2 weeks (as a rule of thumb).\n- a single change in one microservice should NOT require a change in another microservice.\n- it's good if a microservice has one business owner.\n\nLinks:\n- [Microservices Architecture: What, When, and How](https://dzone.com/articles/microservices-architecture-what-when-how)\n\n\n### 1.2. When to build microservices over monolith\nKey points:\n- When you need to define strict boundaries (called bounded contexts) in your system. Why is another question: you may have several teams, you may need to scale, you want to use different technologies, etc.\n- Microservice architecture is NOT free.\n\nLinks:\n- [Microservice Trade-Offs by Martin Fowler](https://www.martinfowler.com/articles/microservice-trade-offs.html)\n- [Should that be a Microservice? Keep These Six Factors in Mind](https://tanzu.vmware.com/content/blog/should-that-be-a-microservice-keep-these-six-factors-in-mind)\n- [Microservices and Their Benefits](https://candost.blog/microservices-and-their-benefits)\n\n\n### 1.3. Why async architecture\n- To make a resilient system which may be updated separately.\n- If we have microservices but they use sync calls we may significantly increase delays and decrease resilience.\n\nRead vs write workload:\n- Read-heavy workload: sync calls are preferrable.\n- Write-heavy workload: async calls are preferrable.\n\nLinks:\n- [Is your microservice a distributed monolith?](https://www.gremlin.com/blog/is-your-microservice-a-distributed-monolith)\n- [Patterns for Microservices â€” Sync vs. Async](https://dzone.com/articles/patterns-for-microservices-sync-vs-async)\n\n\n### 2. How to create a system with async architecture\n1. Business: read (obtain) business requirements.\n2. Event stroming: do event storming.\n3. Data model: write down a data model.\n4. Domains: identify business (not techinical!) domains.\n5. Services: write down a list of services based on your business domains.\n6. Communications: write down how your services will communicate with each other.\n7. Implementation: go and implement it.\n\nCommand/query separation: we either query data or send a command to change system's state. With CQRS we deal with eventual consistency: there is no read your own writes semantics.\n\nEvent storming:\n1. Actor - who/what initiates a command. May be a person, a computer, or another event.\n2. Command - what need to be done, returns only status; or Query - returns data.\n3. Data - data for the corresponding command\n4. Event - happens after command was executed.\n\nData model acts helps to think about the system as a whole after we created many tuples of actor, command, data, event.\n\nDomain: we chose domain right if a small change from a business perspective means a small change in software system.\n\nEvents:\n1. Business events - result of a command (the command may call another command).\n2. CUD-events: create, update, delete events to stream (transmit) data inside our system.\n\nLinks:\n- [CQRS: what, why and how](https://sderosiaux.medium.com/cqrs-what-why-how-945543482313)\n- [Deconstructing Monolithic Applications into Services](https://blog.heroku.com/monolithic-applications-into-services)\n\n### 3. Authentication and Authorization\nAuthN and AuthZ for mnemonics: authentication is usually done first then goes authorizations, so letter N goes first, then goes letter Z.\n\n#### 3.1. Implement AuthN and AuthZ in each service\nWe need to repeat some code and client need to know about the services.\n\n#### 3.2. Use API Gateway pattern\nAPI Gateway is a proxy which routes requests from a client to internal services and can also implement AuthN and AuthZ.\n\n#### 3.3. Single sign-on\n\n\n### 4. Message brokers\nMessage brokers:\n1. Distributed queue\nWe can send a message to an exchange and the exchange will send the message to one or more queues. One message is read by one consumer and then deleted.\nExamples: RabbitMQ, Amazon SQS, NATS.\n2. Distributed log\nGuarantees ordering and usually keeps all messages. One message is read by one or more consumer. Useful when we add a new service: it just need to read an appropriate log to fill it's internal database.\nExamples: Kafka, Google Pub/Sub, Amazon Kinesis, NATS with streaming.\n\nName topics according to business or domain, NOT implementation details.\n\nKafka guaranees ordering inside a partition, NOT a topic. Topic consists of several partitions.\n\nTODO: to be continued\n\n### Related notes\n- [Event-driven systems and Kafka &rarr;](/notes/Event-driven%20systems%20and%20Kafka)"},"__N_SSG":true}