{"pageProps":{"title":"Async architecture","content":"### 1.1. What microservice architecture is\nKey points:\n- a microservice should be rewritten in 2 weeks (as a rule of thumb).\n- a single change in one microservice should NOT require a change in another microservice.\n- it's good if a microservice has one business owner.\n\nLinks:\n- [Microservices Architecture: What, When, and How](https://dzone.com/articles/microservices-architecture-what-when-how)\n\n\n### 1.2. When to build microservices over monolith\nKey points:\n- When you need to define strict boundaries (called bounded contexts) in your system. Why is another question: you may have several teams, you may need to scale, you want to use different technologies, etc.\n- Microservice architecture is NOT free.\n\nLinks:\n- [Microservice Trade-Offs by Martin Fowler](https://www.martinfowler.com/articles/microservice-trade-offs.html)\n- [Should that be a Microservice? Keep These Six Factors in Mind](https://tanzu.vmware.com/content/blog/should-that-be-a-microservice-keep-these-six-factors-in-mind)\n- [Microservices and Their Benefits](https://candost.blog/microservices-and-their-benefits)\n\n\n### 1.3. Why async architecture\n- To make a resilient system which may be updated separately.\n- If we have microservices but they use sync calls we may significantly increase delays and decrease resilience.\n\nRead vs write workload:\n- Read-heavy workload: sync calls are preferrable.\n- Write-heavy workload: async calls are preferrable.\n\nLinks:\n- [Is your microservice a distributed monolith?](https://www.gremlin.com/blog/is-your-microservice-a-distributed-monolith)\n- [Patterns for Microservices â€” Sync vs. Async](https://dzone.com/articles/patterns-for-microservices-sync-vs-async)\n\n\n### 2. How to create a system with async architecture\n1. Business: read (obtain) business requirements.\n2. Event stroming: do event storming.\n3. Data model: write down a data model.\n4. Domains: identify business (not techinical!) domains.\n5. Services: write down a list of services based on your business domains.\n6. Communications: write down how your services will communicate with each other.\n7. Implementation: go and implement it.\n\nCommand/query separation: we either query data or send a command to change system's state.\n\nEvent storming:\n1. Actor - who/what initiates a command. May be a person, a computer, or another event.\n2. Command - what need to be done, returns only status; or Query - returns data.\n3. Data - data for the corresponding command\n4. Event - happens after command was executed.\n\nData model acts helps to think about the system as a whole after we created many tuples of actor, command, data, event.\n\nDomain: we chose domain right if a small change from a business perspective means a small change in software system.\n\nEvents:\n1. Business events - result of a command (the command may call another command).\n2. CUD-events: create, update, delete events to stream (transmit) data inside our system.\n\nLinks:\n- [CQRS: what, why and how](https://sderosiaux.medium.com/cqrs-what-why-how-945543482313)\n- [Deconstructing Monolithic Applications into Services](https://blog.heroku.com/monolithic-applications-into-services)\n\n\nTODO: to be continued\n\n### Related notes\n- [Engineering &rarr;](/notes/Engineering)\n- [Event-driven systems and Kafka &rarr;](/notes/Event-driven%20systems%20and%20Kafka)"},"__N_SSG":true}