{"pageProps":{"title":"Replication","content":"### Replication\nReplication is a process of storing the dame dataset on different nodes in the same cluster.\n\n### When replication is used\n1. When we need a higher availability than in a single-node configuration.\n2. When we have customers in different geographic regions and want to have small latency for all customers.\n3. When we want to scale read queries.\n\n### Leader-based replication\nAll writes go to primary node and the primary node propagates changes to replica nodes. Nodes must agree on which node is master. It must be done in such a way to prevent split brain problem.\n\n### Synchronous vs asyncronous replication\n1. Synchronous: client waits while changes are written to both master and replica.\n2. Asynchronous: client waits while changes are written to master and master asyncronously send changes to replica.\n3. Mix: sometimes one sync and several async replicas are used.\n\n### Replication modes\n- execute statements on each replica (unsafe if we use now() or rand() or similar).\n- propagate write-ahead log to each replica.\n\n### Replication lag\nReplication lag is amount of time while replica hasn't applied changes from master. Usually it's less than a second but sometimes it will take more time, even minutes.\n\n### How to read your own writes\nYou can read important data always from primary node and less important data from replicas.\nYou can also usr another heuristic and probably some cache.\n\n### How to make reads monotonic\nA simple solution is to read from the same replica for this user. We still have a problem if this replica fails.\n\n### Multileader replication\nAvoid it if possible.\n\nOK, you may have to use it if you need to store the same data in different datacenters or you may want to handle more write queries.\n\nThe main problem is how to handle conflicts. CRDT and unique row ids (higher id wins) are usually used. Some people write custom conflict resolution logic but it must return the same value on all leaders. We can't use timestamps or autoincremented numbers.\n\nAnother problem is that changes are not guaranteed to arrive in the same order to all leaders.\n\n### Leaderless replication\nClients send read or write requests to several nodes and it's client responsibility to resolve conflicts.\n\nThis is the most reliable replication model but the tradeoff is that it is the most complex.\n\n### Related notes\n- [Postgres &rarr;](/notes/Postgres)"},"__N_SSG":true}