<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
	<link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css">
	<link rel="icon" 
      type="image/png" 
      href="icon.png">
    <script src="./javascripts/jquery-2.1.1.min.js"></script>
    <script src="./javascripts/main.js"></script>
  </head>
  <style>
  .starter-template {
  	padding-top: 40px;
  	padding-bottom: 40px;
  padding-left: 120px;
  max-width: 75%;
  text-align: justify;}
  .linkbutton{
  	min-width: 350px; margin: 1px;
  }
</style>
<script src="./javascripts/menu.js"></script>
<script src="./bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
<script>
	$(document).ready(function(){
		createMenu("index.html");
	});
</script>
  <body>
    <div class="container">
      <div class="starter-template">
      <h2>Technical blog</h2>
        </br>

	    <a class="btn btn-primary" href="index2.html">Go to Javascript days</a>
	    </br>
		</br>
		</br>


		17.07.2014
		<h3 id="is33">Issue 34: Scala maven configuration</h3>
		<div>
			<a href="scala_maven_config.txt">Can see here</a>
		</div>
		</br></br>
		


		07.07.2014
		<h3 id="is33">Issue 33: What NoSQL solution should use?</h3>
		<div>
			<a href="http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis">Cassandra vs mongodb vs couchdb vs redis</a>
			</br>
			<a href="http://en.wikipedia.org/wiki/Bitmap_index">Bitmap index</a>
		</div>
		</br></br>

		02.07.2014
		<h3 id="is32">Issue 32: Installing nodejs and npm on Ubuntu 14.04</h3>
		<div>
			<a href="http://tecadmin.net/install-latest-nodejs-npm-on-ubuntu/#">The original article</a></br></br>

			Step 1 – Add PPA in System</br></br>

			First add node.js ppa in our system using following set of command. We also need to install python-software-properties package if not installed already.</br></br>

			$ sudo apt-get install python-software-properties</br>
			$ sudo apt-add-repository ppa:chris-lea/node.js</br>
			$ sudo apt-get update</br></br>

			Step 2 – Install Node.js and NPM</br></br>

			After adding required PPA file, lets install nodejs package. NPM will also be installed with node.js. This command will also install many other dependent packages on your system.</br></br>

			$ sudo apt-get install nodejs</br></br>
			
			Step 3 – Check Node.js and NPM Version</br></br>

			After installing node.js verify and check the installed version. You can find more details about current version on node.js official website.</br></br>

			$ node -v </br>

			v0.10.28</br>
			Also check the version of npm.</br>

			$ npm -v </br>

			1.4.9

		</div>
		</br></br>





		<h2>C++ and Qt week</h2>
		25.06.2014

		<h3 id="is31">Issue 31: What means the 'explicit' keyword?</h3>
		<div>
			<a href="http://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-in-c-mean">The original discussion</a></br></br>

			In C++, the compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use single parameter constructors to convert from one type to another in order to get the right type for a parameter. Here's an example class with a constructor that can be used for implicit conversions:</br></br>

			class Foo</br>
			{</br>
			public:</br>
			  // single parameter constructor, can be used as an implicit conversion</br>
			  Foo (int foo) : m_foo (foo) </br>
			  {</br>
			  }</br>
</br>
			  int GetFoo () { return m_foo; }</br>
</br>
			private:</br>
			  int m_foo;</br>
			};</br>
			Here's a simple function that takes a Foo object:</br>
</br>
			void DoBar (Foo foo)</br>
			{</br>
			  int i = foo.GetFoo ();</br>
			}</br>
			and here's where the DoBar function is called.</br>
</br>
			int main ()</br>
			{</br>
			  DoBar (42);</br>
			}</br>
			The parameter is not a Foo object, but an int. However, there exists a constructor for Foo that takes an int so this constructor can be used to convert the parameter to the correct type.</br></br>

			The compiler is allowed to do this once for each parameter.</br></br>

			Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call DoBar (42). It is now necessary to call for conversion explicitly with  DoBar (Foo (42))
		</div>
		</br></br>



		23.06.2014
		<h3 id="is30">Issue 30: What the differences between a pointer variable and a reference variable in C++</h3>
		<div>
			<a href="http://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c">Original discussion</a></br></br>
			1. A pointer can be re-assigned:</br>

			int x = 5;</br>
			int y = 6;</br>
			int *p;</br>
			p =  &x;</br>
			p = &y;</br>
			*p = 10;</br>
			assert(x == 5);</br>
			assert(y == 10);</br>
			A reference cannot, and must be assigned at initialization:</br>

			int x = 5;</br>
			int y = 6;</br>
			int &r = x;</br></br>

			2. A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack. Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable. Note: What a pointer points to can be on the stack or heap. Ditto a reference. My claim in this statement is not that a pointer must point to the stack. A pointer is just a variable that holds a memory address. This variable is on the stack. Since a reference has its own space on the stack, and since the address is the same as the variable it references. More on stack vs heap. This implies that there is a real address of a reference that the compiler will not tell you.</br>

			int x = 0;</br>
			int &r = x;</br>
			int *p = &x;</br>
			int *p2 = &r;</br>
			assert(p == p2);</br></br>

			3. You can have pointers to pointers to pointers offering extra levels of indirection. Whereas references only offer one level of indirection.</br>

			int x = 0;</br>
			int y = 0;</br>
			int *p = &x;</br>
			int *q = &y;</br>
			int **pp = &p;</br>
			pp = &q;//*pp = q</br>
			**pp = 4;</br>
			assert(y == 4);</br>
			assert(x == 0);</br></br>

			4. Pointer can be assigned NULL directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference NULL. Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain NULL.</br>

			int *p = NULL;</br>
			int &r = NULL; <--- compiling error</br></br>

			5. Pointers can iterate over an array, you can use ++ to go to the next item that a pointer is pointing to, and + 4 to go to the 5th element. This is no matter what size the object is that the pointer points to.</br></br>

			6. A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly. A pointer to a class/struct uses -> to access it's members whereas a reference uses a ..</br></br>

			7. A pointer is a variable that holds a memory address. Regardless of how a reference is implemented, a reference has the same memory address as the item it references.</br></br>

			8. References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</br></br>

			9. Const references can be bound to temporaries. Pointers cannot (not without some indirection):</br></br>

			10. const int &x = int(12); //legal C++</br>
			int *y = &int(12); //illegal to dereference a temporary.</br>
			This makes const& safer for use in argument lists and so forth.</br>

		</div>
		</br></br>

		16.06.2014

		<h3 id="is29">Issue 29: Lambdas</h3>
		<div>
			<a href="http://blog.smartbear.com/c-plus-plus/c11-tutorial-lambda-expressions-the-nuts-and-bolts-of-functional-programming/">The original article</a></br></br>
			1. Syntax:</br>
			[capture clause] (parameters) -> return-type {body}</br></br>
			2. Example of basic usage</br>
			vector <accountant> emps {{“Josh”, 2100.0}, {“Kate”, 2900.0}, {“Rose”,1700.0}};</br>
			const auto min_wage = 1600.0;</br>
			const auto upper_limit = 1.5*min_wage;</br>
			//report which accountant has a salary that is within a specific range</br>
			std::find_if(emps.begin(), emps.end(),</br>
			[=](const accountant& a) {return a.salary()>=min_wage && a.salary() < upper_limit;});</br></br>
			3. Capture Lists</br>
			[=] //capture all of the variables from the enclosing scope by value</br>
			[&]//capture all of the variables from the enclosing scope by reference</br>
			[this]//capture all of the data members of the enclosing class</br>
			You can also specify the capture mechanism for individual variables. In the following example min_wage is captured by copy and upper_limit by reference:</br>
			[min_wage, &upper_limit](const accountant& a)->bool</br>
			{return a.salary()>= min_wage && a.salary() < upper_limit;});</br>

			vector<int> v1={0,12,4}, v2={10,12,14,16}; //read about the new C++11 initialization notation</br>
			[&v1](int k) {vi.push_back(k); };  //capture v1 by reference</br>
			[&]  (int m) {v1.push_back(m); v2.push_back(m) };//capture vi and vi2 by ref</br>
			[v1]() //capture v1 by copy</br>
			{for_each(auto y=v1.begin(), y!=v1.end(), y++) {cout<<y<<" ";}};</br></br>
			4. Closures</br>
			auto factorial = [](int i, int j) {return i * j;};</br>
			int arr{1,2,3,4,5,6,7,8,9,10,11,12};</br>
			long res = std::accumulate(arr, arr+12, 1, factorial);</br>
		</div>
		</br></br>

		<h3 id="is28">Issue 28: A little about c++ 2011</h3>
		<div>
			<a href="http://herbsutter.com/elements-of-modern-c-style/">The original article</a></br></br>
			1. Type inference for variables</br>
			auto i = begin(m);</br>
			auto const xlimit = config["xlimit"];</br>
			auto& s = singleton::instance();</br></br>
			2. nullptr</br>
			int* p = nullptr;//not 0</br></br>
			3. Range for</br>
			for( auto d : v ) {</br>
    			total += d;</br>
			}</br></br>
			4. Nonmember begin and end</br>
			vector<int> v;</br>
			int a[100];</br>
			sort( begin(v), end(v) );</br>
			sort( begin(a), end(a) );//the same syntax</br>
		</div>
		</br></br>

		12.06.2014
		<h3 id="is27">Issue 27: Defining an enum and adding support c++ 2011</h3>
		<div>
			Just define</br>
			enum class SystemState { working, stopped, failed };</br>
			and append to the .pro file the string</br>
			CONFIG += c++11
		</div>
		</br></br>


		<h2>Processing week</h2>
		31.05.2014
		<h3 id="is26">Issue 26: Difficulty of software development</h3>
		<div>
		Use small steps with a tiny functionality.</br></br>
		You can't implement some killer feature at one step, but you can
		create some concrete steps to great feature, each of them is one little feature.
		</div>


		</br></br>
		22.05.2014

		<h3 id="is25">Issue 25: Git: there is no tracking information for the current branch</h3>
		<div>
		Instead</br>
		git pull --all</br>
		use</br>
		git pull origin branch_name</br>
		</div>

		<h3 id="is24">Issue 24: Some memorable moments from "Getting real" from 37 signals</h3>
		<div>
			1. Define direction. Shortly.</br>
			2. Right define priorities. You can't do all ASAP. Just define what matters.</br>
			3. Do lean product. Define your users. Define what most needed. Do one feature at a time.</br>
			4. Features must work correctly.</br>
			5. Don't repeat competitors.
		</div>
	  </div>
	</div>






	<!-- Yandex.Metrika informer -->
	<a href="https://metrika.yandex.ru/stat/?id=25630463&amp;from=informer"
	target="_blank" rel="nofollow"><img src="//bs.yandex.ru/informer/25630463/3_0_3EB0FFFF_1E90FFFF_0_pageviews"
	style="width:88px; height:31px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)" onclick="try{Ya.Metrika.informer({i:this,id:25630463,lang:'ru'});return false}catch(e){}"/></a>
	<!-- /Yandex.Metrika informer -->

	<!-- Yandex.Metrika counter -->
	<script type="text/javascript">
	(function (d, w, c) {
	    (w[c] = w[c] || []).push(function() {
	        try {
	            w.yaCounter25630463 = new Ya.Metrika({id:25630463,
	                    clickmap:true,
	                    trackLinks:true,
	                    accurateTrackBounce:true});
	        } catch(e) { }
	    });

	    var n = d.getElementsByTagName("script")[0],
	        s = d.createElement("script"),
	        f = function () { n.parentNode.insertBefore(s, n); };
	    s.type = "text/javascript";
	    s.async = true;
	    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

	    if (w.opera == "[object Opera]") {
	        d.addEventListener("DOMContentLoaded", f, false);
	    } else { f(); }
	})(document, window, "yandex_metrika_callbacks");
	</script>
	<noscript><div><img src="//mc.yandex.ru/watch/25630463" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
	<!-- /Yandex.Metrika counter -->
  </body>
</html>