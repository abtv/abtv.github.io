<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

	<link rel="icon" 
      type="image/png" 
      href="icon.png">

    <script src="./javascripts/jquery-2.1.1.min.js"></script>
    <script src="./javascripts/main.js"></script>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title"/>
          <h2 id="project_tagline"/>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
  
  		&lt;&lt; Still not exists
  		&nbsp;&nbsp;&nbsp;
	    <a href="index2.html">Go to Javascript days and Scala week &gt;&gt; </a>

		</br>
		</br>
		</br>

		<h2>C++ and Qt week</h2>
		23.06.2014


		<h3 id="is30">Issue 30: What the differences between a pointer variable and a reference variable in C++</h3>
		<div>
			<a href="http://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c">Original discussion</a></br></br>
			1. A pointer can be re-assigned:</br>

			int x = 5;</br>
			int y = 6;</br>
			int *p;</br>
			p =  &x;</br>
			p = &y;</br>
			*p = 10;</br>
			assert(x == 5);</br>
			assert(y == 10);</br>
			A reference cannot, and must be assigned at initialization:</br>

			int x = 5;</br>
			int y = 6;</br>
			int &r = x;</br></br>

			2. A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack. Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable. Note: What a pointer points to can be on the stack or heap. Ditto a reference. My claim in this statement is not that a pointer must point to the stack. A pointer is just a variable that holds a memory address. This variable is on the stack. Since a reference has its own space on the stack, and since the address is the same as the variable it references. More on stack vs heap. This implies that there is a real address of a reference that the compiler will not tell you.</br>

			int x = 0;</br>
			int &r = x;</br>
			int *p = &x;</br>
			int *p2 = &r;</br>
			assert(p == p2);</br></br>

			3. You can have pointers to pointers to pointers offering extra levels of indirection. Whereas references only offer one level of indirection.</br>

			int x = 0;</br>
			int y = 0;</br>
			int *p = &x;</br>
			int *q = &y;</br>
			int **pp = &p;</br>
			pp = &q;//*pp = q</br>
			**pp = 4;</br>
			assert(y == 4);</br>
			assert(x == 0);</br></br>

			4. Pointer can be assigned NULL directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference NULL. Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain NULL.</br>

			int *p = NULL;</br>
			int &r = NULL; <--- compiling error</br></br>

			5. Pointers can iterate over an array, you can use ++ to go to the next item that a pointer is pointing to, and + 4 to go to the 5th element. This is no matter what size the object is that the pointer points to.</br></br>

			6. A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly. A pointer to a class/struct uses -> to access it's members whereas a reference uses a ..</br></br>

			7. A pointer is a variable that holds a memory address. Regardless of how a reference is implemented, a reference has the same memory address as the item it references.</br></br>

			8. References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</br></br>

			9. Const references can be bound to temporaries. Pointers cannot (not without some indirection):</br></br>

			10. const int &x = int(12); //legal C++</br>
			int *y = &int(12); //illegal to dereference a temporary.</br>
			This makes const& safer for use in argument lists and so forth.</br>

		</div>
		</br></br>

		16.06.2014

		<h3 id="is29">Issue 29: Lambdas</h3>
		<div>
			<a href="http://blog.smartbear.com/c-plus-plus/c11-tutorial-lambda-expressions-the-nuts-and-bolts-of-functional-programming/">The original article</a></br></br>
			1. Syntax:</br>
			[capture clause] (parameters) -> return-type {body}</br></br>
			2. Example of basic usage</br>
			vector <accountant> emps {{“Josh”, 2100.0}, {“Kate”, 2900.0}, {“Rose”,1700.0}};</br>
			const auto min_wage = 1600.0;</br>
			const auto upper_limit = 1.5*min_wage;</br>
			//report which accountant has a salary that is within a specific range</br>
			std::find_if(emps.begin(), emps.end(),</br>
			[=](const accountant& a) {return a.salary()>=min_wage && a.salary() < upper_limit;});</br></br>
			3. Capture Lists</br>
			[=] //capture all of the variables from the enclosing scope by value</br>
			[&]//capture all of the variables from the enclosing scope by reference</br>
			[this]//capture all of the data members of the enclosing class</br>
			You can also specify the capture mechanism for individual variables. In the following example min_wage is captured by copy and upper_limit by reference:</br>
			[min_wage, &upper_limit](const accountant& a)->bool</br>
			{return a.salary()>= min_wage && a.salary() < upper_limit;});</br>

			vector<int> v1={0,12,4}, v2={10,12,14,16}; //read about the new C++11 initialization notation</br>
			[&v1](int k) {vi.push_back(k); };  //capture v1 by reference</br>
			[&]  (int m) {v1.push_back(m); v2.push_back(m) };//capture vi and vi2 by ref</br>
			[v1]() //capture v1 by copy</br>
			{for_each(auto y=v1.begin(), y!=v1.end(), y++) {cout<<y<<" ";}};</br></br>
			4. Closures</br>
			auto factorial = [](int i, int j) {return i * j;};</br>
			int arr{1,2,3,4,5,6,7,8,9,10,11,12};</br>
			long res = std::accumulate(arr, arr+12, 1, factorial);</br>
		</div>
		</br></br>

		<h3 id="is28">Issue 28: A little about c++ 2011</h3>
		<div>
			<a href="http://herbsutter.com/elements-of-modern-c-style/">The original article</a></br></br>
			1. Type inference for variables</br>
			auto i = begin(m);</br>
			auto const xlimit = config["xlimit"];</br>
			auto& s = singleton::instance();</br></br>
			2. nullptr</br>
			int* p = nullptr;//not 0</br></br>
			3. Range for</br>
			for( auto d : v ) {</br>
    			total += d;</br>
			}</br></br>
			4. Nonmember begin and end</br>
			vector<int> v;</br>
			int a[100];</br>
			sort( begin(v), end(v) );</br>
			sort( begin(a), end(a) );//the same syntax</br>
		</div>
		</br></br>

		12.06.2014
		<h3 id="is27">Issue 27: Defining an enum and adding support c++ 2011</h3>
		<div>
			Just define</br>
			enum class SystemState { working, stopped, failed };</br>
			and append to the .pro file the string</br>
			CONFIG += c++11
		</div>
		</br></br>


		<h2>Processing week</h2>
		31.05.2014
		<h3 id="is26">Issue 26: Difficulty of software development</h3>
		<div>
		Use small steps with a tiny functionality.</br></br>
		You can't implement some killer feature at one step, but you can
		create some concrete steps to great feature, each of them is one little feature.
		</div>


		</br></br>
		22.05.2014

		<h3 id="is25">Issue 25: Git: there is no tracking information for the current branch</h3>
		<div>
		Instead</br>
		git pull --all</br>
		use</br>
		git pull origin branch_name</br>
		</div>

		<h3 id="is24">Issue 24: Some memorable moments from "Getting real" from 37 signals</h3>
		<div>
			1. Define direction. Shortly.</br>
			2. Right define priorities. You can't do all ASAP. Just define what matters.</br>
			3. Do lean product. Define your users. Define what most needed. Do one feature at a time.</br>
			4. Features must work correctly.</br>
			5. Don't repeat competitors.
		</div>
	  </section>
	</div>
  </body>
</html>