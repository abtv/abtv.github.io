<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Encoding and evolution</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-63cdc919fe449cbe88aa.js" defer=""></script><script src="https://abtv.github.io/_next/static/5j62QAwW1XAi8F4ttVCAU/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/5j62QAwW1XAi8F4ttVCAU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">← Main page</a></div><div class="Post_header__2s4s1"><h2>Encoding and evolution</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h4>Encoding</h4>
<p>A serialization process: transform data from memory to buffer and vice versa.</p>
<p>Usually we use some protocol if we want at least one of:</p>
<ol>
<li>Access to the same data from different programming languages.</li>
<li>Use compressed form of data. It is important if we have terabytes of data and more.</li>
</ol>
<h4>Evolution</h4>
<p>A process of data schema changes. Almost any app will evolve over time. We need to support backward and forward compatibility if we want to release without a downtime.</p>
<h4>Compatibility</h4>
<ol>
<li>Backward: new code can read old data format.</li>
<li>Forward: old code can read new data format.</li>
</ol>
<p>Both are required for rolling upgrades.</p>
<h4>Data exchange protocols</h4>
<ul>
<li>XML (optional schema)</li>
<li>JSON (optional schema)</li>
<li>Apache Thrift (required schema)</li>
<li>Protocol buffers (required schema)</li>
<li>Apache Avro (required schema, separates reader and writer schemas)</li>
</ul>
<h4>Dataflow can go through</h4>
<ol>
<li>Database</li>
<li>Remote service calls</li>
<li>Message passing</li>
</ol>
<h4>REST</h4>
<p>Not a protocol but a design philosophy which uses principles of HTTP. Uses URI for resource identification. Relies on HTTP mechanisms for caching and authentication.</p>
<h4>SOAP</h4>
<p>XML-based protocol. Uses code generation. Much harder to use than REST in dynamic languages.</p>
<h4>Related notes</h4>
<ul>
<li><a href="/notes/Engineering">Engineering →</a></li>
</ul></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2021</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Encoding and evolution","content":"#### Encoding\nA serialization process: transform data from memory to buffer and vice versa.\n\nUsually we use some protocol if we want at least one of:\n1. Access to the same data from different programming languages.\n2. Use compressed form of data. It is important if we have terabytes of data and more.\n\n#### Evolution\nA process of data schema changes. Almost any app will evolve over time. We need to support backward and forward compatibility if we want to release without a downtime.\n\n#### Compatibility\n1. Backward: new code can read old data format.\n2. Forward: old code can read new data format.\n\nBoth are required for rolling upgrades.\n\n#### Data exchange protocols\n- XML (optional schema)\n- JSON (optional schema)\n- Apache Thrift (required schema)\n- Protocol buffers (required schema)\n- Apache Avro (required schema, separates reader and writer schemas)\n\n#### Dataflow can go through\n1. Database\n2. Remote service calls\n3. Message passing\n\n#### REST\nNot a protocol but a design philosophy which uses principles of HTTP. Uses URI for resource identification. Relies on HTTP mechanisms for caching and authentication.\n\n#### SOAP\nXML-based protocol. Uses code generation. Much harder to use than REST in dynamic languages.\n\n#### Related notes\n- [Engineering \u0026rarr;](/notes/Engineering)"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Encoding and evolution"},"buildId":"5j62QAwW1XAi8F4ttVCAU","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>