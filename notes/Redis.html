<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Redis</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-63cdc919fe449cbe88aa.js" defer=""></script><script src="https://abtv.github.io/_next/static/5j62QAwW1XAi8F4ttVCAU/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/5j62QAwW1XAi8F4ttVCAU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">← Main page</a></div><div class="Post_header__2s4s1"><h2>Redis</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h4>What it is</h4>
<p>Redis is an in-memory database. Usually it is used as a secondary database.</p>
<h4>Use cases</h4>
<ol>
<li>Cache.</li>
<li>Queue.</li>
<li>Message broker.</li>
<li>Rate-limiter.</li>
<li>Atomic counters.</li>
</ol>
<h4>Protocol</h4>
<p>Redis uses a simple text protocol for issuing and receiving commands.</p>
<h4>Implementation</h4>
<p>Redis uses a single thread to execute commands. It is a design choice.</p>
<h4>Transactions</h4>
<p>It is NOT the same transaction as in a relational database. If one command in a transaction fails all the other transactions WILL be executed (there is no rollback).</p>
<p>Using &quot;Multi, commands list, Exec&quot; Redis guarantees that these commands will be run one after another and all other commands will be run either before or after the commands.</p>
<p>Multi starts queuing consequent commands. Exec runs their execution.</p>
<p>WATCH in combination with EXEC is used for optimistic locking. If one of watched keys was modified EXEC will fail.</p>
<p><a href="https://redis.io/topics/transactions">Transactions</a></p>
<h4>Message broker</h4>
<p>We can send a message to a channel. One channel has several subscribers. Commands are: subscribe, unsubscribe and publish.</p>
<h4>Special data types</h4>
<p>Bitmap for bit operations to save memory.
HyperLogLog for probabalistic counting of unique elements in a set to save memory.</p>
<h4>Storage</h4>
<p>Redis database snapshots (RDB):
Stores data in-memory and saves the memory snapshot to disk from time to time as an RDB file. It uses forked process to create a snapshot, so it does not affect performace of the original process. Fork uses copy-on-write, so it is fast.</p>
<p>Append-only file (AOF):
Writes all commands issued against the Redis server. The file will be big because one value stored is only once but may be modified many times (there is a command to rewrite the file when it becomes too big). Durability depends how often you call fsync.</p>
<p>Restoring from RDB snapshot is faster than applying AOF.</p>
<p><a href="https://redis.io/topics/persistence#append-only-file">Append-only file</a></p>
<p><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">Redis persistence demystified</a></p>
<h4>Roundtrip time (RTT) and pipelinening</h4>
<p>When a command is sent the client is blocked until we get a response from the redis server. If we want to avoid the roundtrip time we need to send all commands at a time or use batches. This feature is called pipelining.</p>
<h4>Availability and failover</h4>
<p>Redis uses replicas to support high availability.
We need one primary node, one replica and at least 3 Sentinel instances to have a quorum. Sentinel instances may be run on the same machine as Redis. For big installations we may want to have 2 big Redis machines and 3 small Sentinel machines.
Redis uses asynchronous replication: if master fails then replica may be slightly outdated.</p>
<p>Redis uses shards to scale horizontally. Cluster is a collection of shards.</p>
<h4>Operating system support</h4>
<ol>
<li>Linux is recommended.</li>
<li>Mac OS.</li>
</ol>
<h4>Related notes</h4>
<ul>
<li><a href="/notes/Engineering">Engineering →</a></li>
</ul></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2021</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Redis","content":"#### What it is\nRedis is an in-memory database. Usually it is used as a secondary database.\n\n#### Use cases\n1. Cache.\n2. Queue.\n3. Message broker.\n4. Rate-limiter.\n5. Atomic counters.\n\n#### Protocol\nRedis uses a simple text protocol for issuing and receiving commands.\n\n#### Implementation\nRedis uses a single thread to execute commands. It is a design choice.\n\n#### Transactions\nIt is NOT the same transaction as in a relational database. If one command in a transaction fails all the other transactions WILL be executed (there is no rollback).\n\nUsing \"Multi, commands list, Exec\" Redis guarantees that these commands will be run one after another and all other commands will be run either before or after the commands.\n\nMulti starts queuing consequent commands. Exec runs their execution.\n\nWATCH in combination with EXEC is used for optimistic locking. If one of watched keys was modified EXEC will fail.\n\n[Transactions](https://redis.io/topics/transactions)\n\n#### Message broker\nWe can send a message to a channel. One channel has several subscribers. Commands are: subscribe, unsubscribe and publish.\n\n#### Special data types\nBitmap for bit operations to save memory.\nHyperLogLog for probabalistic counting of unique elements in a set to save memory.\n\n#### Storage\nRedis database snapshots (RDB):\nStores data in-memory and saves the memory snapshot to disk from time to time as an RDB file. It uses forked process to create a snapshot, so it does not affect performace of the original process. Fork uses copy-on-write, so it is fast.\n\nAppend-only file (AOF):\nWrites all commands issued against the Redis server. The file will be big because one value stored is only once but may be modified many times (there is a command to rewrite the file when it becomes too big). Durability depends how often you call fsync.\n\nRestoring from RDB snapshot is faster than applying AOF.\n\n[Append-only file](https://redis.io/topics/persistence#append-only-file)\n\n[Redis persistence demystified](http://oldblog.antirez.com/post/redis-persistence-demystified.html)\n\n#### Roundtrip time (RTT) and pipelinening\nWhen a command is sent the client is blocked until we get a response from the redis server. If we want to avoid the roundtrip time we need to send all commands at a time or use batches. This feature is called pipelining.\n\n#### Availability and failover\nRedis uses replicas to support high availability.\nWe need one primary node, one replica and at least 3 Sentinel instances to have a quorum. Sentinel instances may be run on the same machine as Redis. For big installations we may want to have 2 big Redis machines and 3 small Sentinel machines.\nRedis uses asynchronous replication: if master fails then replica may be slightly outdated.\n\nRedis uses shards to scale horizontally. Cluster is a collection of shards.\n\n#### Operating system support\n1. Linux is recommended.\n2. Mac OS.\n\n#### Related notes\n- [Engineering \u0026rarr;](/notes/Engineering)"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Redis"},"buildId":"5j62QAwW1XAi8F4ttVCAU","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>