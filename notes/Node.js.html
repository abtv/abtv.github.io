<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Node.js</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-2f6f3e593fa1668a4ab5.js" defer=""></script><script src="https://abtv.github.io/_next/static/Qj1QvXwo3TQ2FyXdUv3zI/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/Qj1QvXwo3TQ2FyXdUv3zI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">‚Üê Main page</a></div><div class="Post_header__2s4s1"><h2>Node.js</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h3>1. Node.js architecture</h3>
<h4>Main components</h4>
<ol>
<li>JavaScript is run in a single thread with V8 engine.</li>
<li>I/O is implemented with libuv library.</li>
<li>C++ addons for low-level operations like compression or encryption.</li>
</ol>
<h4>Difference between network and file I/O</h4>
<ol>
<li>Network I/O uses operating system notification mechanisms.</li>
<li>Thread pool is used for file I/O because file operations are blocking in libuv. Libuv developers decided to simplify file I/O implementation.</li>
</ol>
<p><code>process.env.UV_THREADPOOL_SIZE</code> is used to set number of threads in the pool. By default the thread pool has 4 threads. The threadpool is also used for compression and encryption.</p>
<h4>Event loop</h4>
<p>Event loop consists of several phases. Each phase has a FIFO queue of callbacks. Phase is finished when either all callback were called or when a sertain limit of calls was reached.</p>
<ol>
<li>Timers: executes callbacks scheduled with setTimeout and setInterval.</li>
<li>Pending callbacks: executes callbacks deferred to the next iteration (due to a limit of calls).</li>
<li>Idle, prepare: used internally.</li>
<li>Poll: retrieves new I/O events and execute all I/O callbacks (except socket closing).</li>
<li>Check: executes callbacks scheduled with setImmediate. Useful in I/O callbacks to run something right after poll phase was finished.</li>
<li>Close callbacks: socket close callbacks.
<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></li>
</ol>
<h4>process.nextTick</h4>
<p>nextTick callback is executed right after current operation finishes before other callbacks in a queue. In this sense setImmediate should be called nextTick.</p>
<h4>Memory</h4>
<ol>
<li>Code</li>
<li>Call stack</li>
<li>Heap</li>
</ol>
<p>By default it&#x27;s 1.4 Gb. <code>--max-old-space-size</code> allows to increase memory limit.</p>
<h4>Garbage collector</h4>
<p>Heap separated into two spaces:</p>
<ol>
<li>New space. Usually from 1 to 8 Mb. Garbage collection is performed frequently here.</li>
<li>Old space. Garbage collection is rare here.</li>
</ol>
<h4>See also</h4>
<ul>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick">The Node.js event loop, Timers, and process.nextTick</a></li>
<li><a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop">Don&#x27;t block the event loop</a></li>
<li><a href="https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1">Node.js event loop</a></li>
<li><a href="https://www.smashingmagazine.com/2020/04/nodejs-internals">Exploring Node.js internals</a></li>
</ul>
<h3>2. Node.js cluster</h3>
<h4>Cluster mode</h4>
<p>Cluster mode is a mode when the main process is forked as many times as we need (usually equals to the number of cores).</p>
<p>Forked processes reuse the same port of HTTP server.</p>
<h3>3. Node.js ORMs</h3>
<h4>Definition</h4>
<p>ORM is a library which allows to work with relational databases in object-oriented languages.</p>
<h4>TypeORM</h4>
<p>Implements data mapper pattern: model object doesn&#x27;t know about persistance and has data fields and business logic. Repositories are used for CRUD operations.</p>
<h4>Sequelize</h4>
<p>Follows active record pattern: model object has data fields, business logic and database CRUD functions.</p>
<h4>Prisma</h4>
<p>Query builder. Generates data types from a schema definition. Uses typed functions almost everywhere. Prisma objects have only data, there is no behavior. Almost no raw queries.</p></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2022</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Node.js","content":"### 1. Node.js architecture\n\n#### Main components\n1. JavaScript is run in a single thread with V8 engine.\n2. I/O is implemented with libuv library.\n3. C++ addons for low-level operations like compression or encryption.\n\n#### Difference between network and file I/O\n1. Network I/O uses operating system notification mechanisms.\n2. Thread pool is used for file I/O because file operations are blocking in libuv. Libuv developers decided to simplify file I/O implementation. \n\n`process.env.UV_THREADPOOL_SIZE` is used to set number of threads in the pool. By default the thread pool has 4 threads. The threadpool is also used for compression and encryption.\n\n#### Event loop\nEvent loop consists of several phases. Each phase has a FIFO queue of callbacks. Phase is finished when either all callback were called or when a sertain limit of calls was reached.\n1. Timers: executes callbacks scheduled with setTimeout and setInterval.\n2. Pending callbacks: executes callbacks deferred to the next iteration (due to a limit of calls).\n3. Idle, prepare: used internally.\n4. Poll: retrieves new I/O events and execute all I/O callbacks (except socket closing).\n5. Check: executes callbacks scheduled with setImmediate. Useful in I/O callbacks to run something right after poll phase was finished.\n6. Close callbacks: socket close callbacks.\nhttps://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n#### process.nextTick\nnextTick callback is executed right after current operation finishes before other callbacks in a queue. In this sense setImmediate should be called nextTick.\n\n#### Memory\n1. Code\n2. Call stack\n3. Heap\n\n\nBy default it's 1.4 Gb. `--max-old-space-size` allows to increase memory limit.\n\n#### Garbage collector\nHeap separated into two spaces:\n1. New space. Usually from 1 to 8 Mb. Garbage collection is performed frequently here.\n2. Old space. Garbage collection is rare here.\n\n#### See also\n- [The Node.js event loop, Timers, and process.nextTick](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick)\n- [Don't block the event loop](https://nodejs.org/en/docs/guides/dont-block-the-event-loop)\n- [Node.js event loop](https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1)\n- [Exploring Node.js internals](https://www.smashingmagazine.com/2020/04/nodejs-internals)\n\n### 2. Node.js cluster\n\n#### Cluster mode\nCluster mode is a mode when the main process is forked as many times as we need (usually equals to the number of cores).\n\nForked processes reuse the same port of HTTP server.\n\n### 3. Node.js ORMs\n\n#### Definition\nORM is a library which allows to work with relational databases in object-oriented languages.\n\n#### TypeORM\nImplements data mapper pattern: model object doesn't know about persistance and has data fields and business logic. Repositories are used for CRUD operations.\n\n#### Sequelize\nFollows active record pattern: model object has data fields, business logic and database CRUD functions.\n\n#### Prisma\nQuery builder. Generates data types from a schema definition. Uses typed functions almost everywhere. Prisma objects have only data, there is no behavior. Almost no raw queries.\n"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Node.js"},"buildId":"Qj1QvXwo3TQ2FyXdUv3zI","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>