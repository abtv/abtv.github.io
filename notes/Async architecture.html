<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Async architecture</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/3fecac13a3874b4c2251.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-63cdc919fe449cbe88aa.js" defer=""></script><script src="https://abtv.github.io/_next/static/ZwWCaKPkTauW6siY2_q-R/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/ZwWCaKPkTauW6siY2_q-R/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">← Main page</a></div><div class="Post_header__2s4s1"><h2>Async architecture</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h3>1.1. What microservice architecture is</h3>
<p>Key points:</p>
<ul>
<li>a microservice should be rewritten in 2 weeks (as a rule of thumb).</li>
<li>a single change in one microservice should NOT require a change in another microservice.</li>
<li>it&#x27;s good if a microservice has one business owner.</li>
</ul>
<p>Links:</p>
<ul>
<li><a href="https://dzone.com/articles/microservices-architecture-what-when-how">Microservices Architecture: What, When, and How</a></li>
</ul>
<h3>1.2. When to build microservices over monolith</h3>
<p>Key points:</p>
<ul>
<li>When you need to define strict boundaries (called bounded contexts) in your system. Why is another question: you may have several teams, you may need to scale, you want to use different technologies, etc.</li>
<li>Microservice architecture is NOT free.</li>
</ul>
<p>Links:</p>
<ul>
<li><a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">Microservice Trade-Offs by Martin Fowler</a></li>
<li><a href="https://tanzu.vmware.com/content/blog/should-that-be-a-microservice-keep-these-six-factors-in-mind">Should that be a Microservice? Keep These Six Factors in Mind</a></li>
<li><a href="https://candost.blog/microservices-and-their-benefits">Microservices and Their Benefits</a></li>
</ul>
<h3>1.3. Why async architecture</h3>
<ul>
<li>To make a resilient system which may be updated separately.</li>
<li>If we have microservices but they use sync calls we may significantly increase delays and decrease resilience.</li>
</ul>
<p>Read vs write workload:</p>
<ul>
<li>Read-heavy workload: sync calls are preferrable.</li>
<li>Write-heavy workload: async calls are preferrable.</li>
</ul>
<p>Links:</p>
<ul>
<li><a href="https://www.gremlin.com/blog/is-your-microservice-a-distributed-monolith">Is your microservice a distributed monolith?</a></li>
<li><a href="https://dzone.com/articles/patterns-for-microservices-sync-vs-async">Patterns for Microservices — Sync vs. Async</a></li>
</ul>
<h3>2. How to create a system with async architecture</h3>
<ol>
<li>Business: read (obtain) business requirements.</li>
<li>Event stroming: do event storming.</li>
<li>Data model: write down a data model.</li>
<li>Domains: identify business (not techinical!) domains.</li>
<li>Services: write down a list of services based on your business domains.</li>
<li>Communications: write down how your services will communicate with each other.</li>
<li>Implementation: go and implement it.</li>
</ol>
<p>Command/query separation: we either query data or send a command to change system&#x27;s state.</p>
<p>Event storming:</p>
<ol>
<li>Actor - who/what initiates a command. May be a person, a computer, or another event.</li>
<li>Command - what need to be done, returns only status; or Query - returns data.</li>
<li>Data - data for the corresponding command</li>
<li>Event - happens after command was executed.</li>
</ol>
<p>Data model acts helps to think about the system as a whole after we created many tuples of actor, command, data, event.</p>
<p>Domain: we chose domain right if a small change from a business perspective means a small change in software system.</p>
<p>Events:</p>
<ol>
<li>Business events - result of a command (the command may call another command).</li>
<li>CUD-events: create, update, delete events to stream (transmit) data inside our system.</li>
</ol>
<p>Links:</p>
<ul>
<li><a href="https://sderosiaux.medium.com/cqrs-what-why-how-945543482313">CQRS: what, why and how</a></li>
<li><a href="https://blog.heroku.com/monolithic-applications-into-services">Deconstructing Monolithic Applications into Services</a></li>
</ul>
<p>TODO: to be continued</p>
<h3>Related notes</h3>
<ul>
<li><a href="/notes/Engineering">Engineering →</a></li>
<li><a href="/notes/Event-driven%20systems%20and%20Kafka">Event-driven systems and Kafka →</a></li>
</ul></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2021</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Async architecture","content":"### 1.1. What microservice architecture is\nKey points:\n- a microservice should be rewritten in 2 weeks (as a rule of thumb).\n- a single change in one microservice should NOT require a change in another microservice.\n- it's good if a microservice has one business owner.\n\nLinks:\n- [Microservices Architecture: What, When, and How](https://dzone.com/articles/microservices-architecture-what-when-how)\n\n\n### 1.2. When to build microservices over monolith\nKey points:\n- When you need to define strict boundaries (called bounded contexts) in your system. Why is another question: you may have several teams, you may need to scale, you want to use different technologies, etc.\n- Microservice architecture is NOT free.\n\nLinks:\n- [Microservice Trade-Offs by Martin Fowler](https://www.martinfowler.com/articles/microservice-trade-offs.html)\n- [Should that be a Microservice? Keep These Six Factors in Mind](https://tanzu.vmware.com/content/blog/should-that-be-a-microservice-keep-these-six-factors-in-mind)\n- [Microservices and Their Benefits](https://candost.blog/microservices-and-their-benefits)\n\n\n### 1.3. Why async architecture\n- To make a resilient system which may be updated separately.\n- If we have microservices but they use sync calls we may significantly increase delays and decrease resilience.\n\nRead vs write workload:\n- Read-heavy workload: sync calls are preferrable.\n- Write-heavy workload: async calls are preferrable.\n\nLinks:\n- [Is your microservice a distributed monolith?](https://www.gremlin.com/blog/is-your-microservice-a-distributed-monolith)\n- [Patterns for Microservices — Sync vs. Async](https://dzone.com/articles/patterns-for-microservices-sync-vs-async)\n\n\n### 2. How to create a system with async architecture\n1. Business: read (obtain) business requirements.\n2. Event stroming: do event storming.\n3. Data model: write down a data model.\n4. Domains: identify business (not techinical!) domains.\n5. Services: write down a list of services based on your business domains.\n6. Communications: write down how your services will communicate with each other.\n7. Implementation: go and implement it.\n\nCommand/query separation: we either query data or send a command to change system's state.\n\nEvent storming:\n1. Actor - who/what initiates a command. May be a person, a computer, or another event.\n2. Command - what need to be done, returns only status; or Query - returns data.\n3. Data - data for the corresponding command\n4. Event - happens after command was executed.\n\nData model acts helps to think about the system as a whole after we created many tuples of actor, command, data, event.\n\nDomain: we chose domain right if a small change from a business perspective means a small change in software system.\n\nEvents:\n1. Business events - result of a command (the command may call another command).\n2. CUD-events: create, update, delete events to stream (transmit) data inside our system.\n\nLinks:\n- [CQRS: what, why and how](https://sderosiaux.medium.com/cqrs-what-why-how-945543482313)\n- [Deconstructing Monolithic Applications into Services](https://blog.heroku.com/monolithic-applications-into-services)\n\n\nTODO: to be continued\n\n### Related notes\n- [Engineering \u0026rarr;](/notes/Engineering)\n- [Event-driven systems and Kafka \u0026rarr;](/notes/Event-driven%20systems%20and%20Kafka)"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Async architecture"},"buildId":"ZwWCaKPkTauW6siY2_q-R","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>