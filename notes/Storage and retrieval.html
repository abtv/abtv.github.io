<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Storage and retrieval</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-63cdc919fe449cbe88aa.js" defer=""></script><script src="https://abtv.github.io/_next/static/5XkGgP3tqjqH6_D10TFaV/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/5XkGgP3tqjqH6_D10TFaV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">‚Üê Main page</a></div><div class="Post_header__2s4s1"><h2>Storage and retrieval</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h3>Tradeoff between writing and reading speed</h3>
<p>The fastest way to save data is to write it to a flat file. The problem is that we will have to full scan the file to make a query.</p>
<p>To make retieval faster we need to write data in such a way to not petform a full scan.</p>
<p>The example below has a very good writing speed but uses a sequential scan for search and therefore it&#x27;s slow.</p>
<pre><code class="language-bash">set () {
 echo &quot;$1,$2&quot; &gt;&gt; file
}

get () {
 grep &quot;^$1,&quot; file | sed -e &quot;s/^$1,//&quot; | tail -n 1
}
</code></pre>
<h4>Segments</h4>
<p>When we update a record in a database we can save the whole new value again and again. At some point of time we can delete obsolete values and compact our file. That&#x27;s why we need segments: we always write to the latest segment and another process may compress previous segment.</p>
<p>If segments are append only we will have less bugs because we can write using one process and read using multiple processes.</p>
<p>Usually a segment is several megabytes in size or more.</p>
<h4>Indexes</h4>
<p>Indexes are used to speedup reading if we need a subset of data.</p>
<h4>Hash indexes</h4>
<p>We can store keys in RAM in a hashmap and point (as byte offset) to values on a disk.
If we reboot we will need to reread segment files to restore the index in RAM.</p>
<h4>SS-tables and LSM-trees</h4>
<p>Sorted string table has keys ordered in each segment and each key may exist at most once in each segment. Such segments are efficiently sorted with mergesort. SS-table may store either key with value or key with offset to a file with data. SS-table is immutable when it is stored on disk.</p>
<p>We can also create an in-memory index for segment files and it will require much less memory because we need to keep only a subset of the keys (assuming that reading several kb is cheap).</p>
<p>Log-structured merge tree (LSM tree) is a cascade of SS-tables that are merging in background.</p>
<p>Bloom filter is used to quickly check if a given key exists in the database.</p>
<p>Examples: LevelDB, RocksDB, Lucene.</p>
<h4>B-trees</h4>
<p>B-tree breaks a database index into pages of about 4Kb in size. This is a smallest block which can be effectively read or written.</p>
<p>Each page may refer to several other pages on disk.</p>
<p>To make a safe b-tree update like a page split we need to use write ahead log.</p>
<p>Examples: almost any relational database.</p>
<h4>LSM-trees vs B-trees</h4>
<p>LSM-trees are faster for writing operations.
B-trees are faster for reading operations.</p>
<h4>Layers</h4>
<p>As we can see usually databases are implemented in several layers: they use such approaches as background merges or changelog to improve performance/reliablity.</p>
<h4>OLTP vs OLAP</h4>
<p>OLTP is usually used to run many low latency queries.
OLAP is usually used to run a small number of long-running queries.</p>
<p>OLAP database is usually filled from OLTP database. OLAP databases also called warehouses. They usually have star schema or snowflake schema: facts table with many related detail tables.</p>
<h4>Column-oriented storage</h4>
<p>Relational databases usually store all row fields together. If we need to access only a small number of fields in one query we can store values from each column together. This is useful for OLAP.</p>
<h4>Bitmap storage</h4>
<p>If we want to store country then we need about 200 values. We can create 200 bitmaps where 1 means value of a given country and 0 means it is not. These  bitmaps may be compressed too.</p></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2021</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Storage and retrieval","content":"### Tradeoff between writing and reading speed\nThe fastest way to save data is to write it to a flat file. The problem is that we will have to full scan the file to make a query.\n\nTo make retieval faster we need to write data in such a way to not petform a full scan.\n\nThe example below has a very good writing speed but uses a sequential scan for search and therefore it's slow.\n```bash\nset () {\n echo \"$1,$2\" \u003e\u003e file\n}\n\nget () {\n grep \"^$1,\" file | sed -e \"s/^$1,//\" | tail -n 1\n}\n```\n\n#### Segments\nWhen we update a record in a database we can save the whole new value again and again. At some point of time we can delete obsolete values and compact our file. That's why we need segments: we always write to the latest segment and another process may compress previous segment.\n\nIf segments are append only we will have less bugs because we can write using one process and read using multiple processes.\n\nUsually a segment is several megabytes in size or more.\n\n#### Indexes\nIndexes are used to speedup reading if we need a subset of data.\n\n#### Hash indexes\nWe can store keys in RAM in a hashmap and point (as byte offset) to values on a disk.\nIf we reboot we will need to reread segment files to restore the index in RAM.\n\n#### SS-tables and LSM-trees\nSorted string table has keys ordered in each segment and each key may exist at most once in each segment. Such segments are efficiently sorted with mergesort. SS-table may store either key with value or key with offset to a file with data. SS-table is immutable when it is stored on disk.\n\nWe can also create an in-memory index for segment files and it will require much less memory because we need to keep only a subset of the keys (assuming that reading several kb is cheap).\n\nLog-structured merge tree (LSM tree) is a cascade of SS-tables that are merging in background.\n\nBloom filter is used to quickly check if a given key exists in the database.\n\nExamples: LevelDB, RocksDB, Lucene.\n\n#### B-trees\nB-tree breaks a database index into pages of about 4Kb in size. This is a smallest block which can be effectively read or written.\n\nEach page may refer to several other pages on disk.\n\nTo make a safe b-tree update like a page split we need to use write ahead log.\n\nExamples: almost any relational database.\n\n#### LSM-trees vs B-trees\nLSM-trees are faster for writing operations.\nB-trees are faster for reading operations.\n\n#### Layers\nAs we can see usually databases are implemented in several layers: they use such approaches as background merges or changelog to improve performance/reliablity.\n\n#### OLTP vs OLAP\nOLTP is usually used to run many low latency queries.\nOLAP is usually used to run a small number of long-running queries.\n\nOLAP database is usually filled from OLTP database. OLAP databases also called warehouses. They usually have star schema or snowflake schema: facts table with many related detail tables.\n\n#### Column-oriented storage\nRelational databases usually store all row fields together. If we need to access only a small number of fields in one query we can store values from each column together. This is useful for OLAP.\n\n#### Bitmap storage\nIf we want to store country then we need about 200 values. We can create 200 bitmaps where 1 means value of a given country and 0 means it is not. These  bitmaps may be compressed too.\n"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Storage and retrieval"},"buildId":"5XkGgP3tqjqH6_D10TFaV","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>