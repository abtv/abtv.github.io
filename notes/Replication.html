<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Replication</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/910f3cf9200776dc6138.css" data-n-g=""/><link rel="preload" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" as="style"/><link rel="stylesheet" href="https://abtv.github.io/_next/static/css/065d9f208d7ce6a4c5de.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://abtv.github.io/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="https://abtv.github.io/_next/static/chunks/webpack-ea2473d7256b97f36886.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/_app-68998cd3c2087b94033f.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/832-1d93ef3dd096bfa087f2.js" defer=""></script><script src="https://abtv.github.io/_next/static/chunks/pages/notes/%5Bid%5D-63cdc919fe449cbe88aa.js" defer=""></script><script src="https://abtv.github.io/_next/static/he7QTn5bDu21MeHKQu2MR/_buildManifest.js" defer=""></script><script src="https://abtv.github.io/_next/static/he7QTn5bDu21MeHKQu2MR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-wrapper"><div class="page-content"><div class="Post_article__f3v0Q"><div class="Post_header__2s4s1"><a href="/">← Main page</a></div><div class="Post_header__2s4s1"><h2>Replication</h2></div><main class="Post_main__2fGnD"><div class="Post_grid__1uhVO"><div class="note-wrapper"><h3>Replication</h3>
<p>Replication is a process of storing the dame dataset on different nodes in the same cluster.</p>
<h3>When replication is used</h3>
<ol>
<li>When we need a higher availability than in a single-node configuration.</li>
<li>When we have customers in different geographic regions and want to have small latency for all customers.</li>
<li>When we want to scale read queries.</li>
</ol>
<h3>Leader-based replication</h3>
<p>All writes go to primary node and the primary node propagates changes to replica nodes. Nodes must agree on which node is master. It must be done in such a way to prevent split brain problem.</p>
<h3>Synchronous vs asyncronous replication</h3>
<ol>
<li>Synchronous: client waits while changes are written to both master and replica.</li>
<li>Asynchronous: client waits while changes are written to master and master asyncronously send changes to replica.</li>
<li>Mix: sometimes one sync and several async replicas are used.</li>
</ol>
<h3>Replication modes</h3>
<ul>
<li>execute statements on each replica (unsafe if we use now() or rand() or similar).</li>
<li>propagate write-ahead log to each replica.</li>
</ul>
<h3>Replication lag</h3>
<p>Replication lag is amount of time while replica hasn&#x27;t applied changes from master. Usually it&#x27;s less than a second but sometimes it will take more time, even minutes.</p>
<h3>How to read your own writes</h3>
<p>You can read important data always from primary node and less important data from replicas.
You can also usr another heuristic and probably some cache.</p>
<h3>How to make reads monotonic</h3>
<p>A simple solution is to read from the same replica for this user. We still have a problem if this replica fails.</p>
<h3>Multileader replication</h3>
<p>Avoid it if possible.</p>
<p>OK, you may have to use it if you need to store the same data in different datacenters or you may want to handle more write queries.</p>
<p>The main problem is how to handle conflicts. CRDT and unique row ids (higher id wins) are usually used. Some people write custom conflict resolution logic but it must return the same value on all leaders. We can&#x27;t use timestamps or autoincremented numbers.</p>
<p>Another problem is that changes are not guaranteed to arrive in the same order to all leaders.</p>
<h3>Leaderless replication</h3>
<p>Clients send read or write requests to several nodes and it&#x27;s client responsibility to resolve conflicts.</p>
<p>This is the most reliable replication model but the tradeoff is that it is the most complex.</p>
<h3>Related notes</h3>
<ul>
<li><a href="/notes/Postgres">Postgres →</a></li>
</ul></div></div></main></div></div><footer class="page-footer"><a href="/">Andrey Butov 2014-2021</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Replication","content":"### Replication\nReplication is a process of storing the dame dataset on different nodes in the same cluster.\n\n### When replication is used\n1. When we need a higher availability than in a single-node configuration.\n2. When we have customers in different geographic regions and want to have small latency for all customers.\n3. When we want to scale read queries.\n\n### Leader-based replication\nAll writes go to primary node and the primary node propagates changes to replica nodes. Nodes must agree on which node is master. It must be done in such a way to prevent split brain problem.\n\n### Synchronous vs asyncronous replication\n1. Synchronous: client waits while changes are written to both master and replica.\n2. Asynchronous: client waits while changes are written to master and master asyncronously send changes to replica.\n3. Mix: sometimes one sync and several async replicas are used.\n\n### Replication modes\n- execute statements on each replica (unsafe if we use now() or rand() or similar).\n- propagate write-ahead log to each replica.\n\n### Replication lag\nReplication lag is amount of time while replica hasn't applied changes from master. Usually it's less than a second but sometimes it will take more time, even minutes.\n\n### How to read your own writes\nYou can read important data always from primary node and less important data from replicas.\nYou can also usr another heuristic and probably some cache.\n\n### How to make reads monotonic\nA simple solution is to read from the same replica for this user. We still have a problem if this replica fails.\n\n### Multileader replication\nAvoid it if possible.\n\nOK, you may have to use it if you need to store the same data in different datacenters or you may want to handle more write queries.\n\nThe main problem is how to handle conflicts. CRDT and unique row ids (higher id wins) are usually used. Some people write custom conflict resolution logic but it must return the same value on all leaders. We can't use timestamps or autoincremented numbers.\n\nAnother problem is that changes are not guaranteed to arrive in the same order to all leaders.\n\n### Leaderless replication\nClients send read or write requests to several nodes and it's client responsibility to resolve conflicts.\n\nThis is the most reliable replication model but the tradeoff is that it is the most complex.\n\n### Related notes\n- [Postgres \u0026rarr;](/notes/Postgres)"},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"Replication"},"buildId":"he7QTn5bDu21MeHKQu2MR","assetPrefix":"https://abtv.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>